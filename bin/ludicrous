#! /usr/bin/ruby1.8

require 'ludicrous'
require 'optparse'
require 'logger'

module JIT
  # TODO: Unused?
  module CompileDerivedClasses
    def inherited(klass)
      super(klass)
      klass.go_plaid
    end
  end
end

LUDICROUS_CALL_TOPLEVEL = proc { |f| f.apply }

class LudicrousRunner
  COPYRIGHT = "TODO"
  VERSION = "TODO"

  def initialize(args, binding, toplevel_self)
    @args = args
    @binding = binding
    @toplevel_self = toplevel_self
    @dash_e = []
    @require = []
    @cd = nil
    @options = Ludicrous::CompileOptions.new
    @ruby_prof = false
    @ruby_prof_printer = "FlatPrinter"
    @ruby_prof_file = nil
    parse(args)
  end

  def parse(args)
    opts = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [switches] [--] [programfile] [arguments]"
      opts.summary_width = 15
      opts.summary_indent = '  '

      opts.on(
          "-e line",
          "one line of script. Several -e's allowed. Omit [programfile]") do |line|
        @dash_e << line
      end

      opts.on(
          "-I path",
          "specify $LOAD_PATH directory (may be used more than once)") do |dir|
        $: << dir
      end

      opts.on(
          "-r library",
          "require the library, before executing your script") do |feature|
            puts "Turning on warnings"
        @require << feature
      end

      opts.on(
          "-v",
          "print version number, then turn on verbose mode") do |verbose|
            puts "Turning on warnings"
        puts VERSION
        $VERBOSE = verbose
      end

      opts.on(
          "-w",
          "turn on warnings for your script") do |verbose|
            puts "Turning on warnings"
        $VERBOSE = verbose
      end

      opts.on(
          "-C directory",
          "cd to directory, before executing your script") do |dir|
        @cd = dir
      end

      opts.on_tail(
          "--jit-log[=lvl]",
          "turn on logging for JIT compilation") do |lvl|
        enable_jit_log(lvl)
      end

      opts.on_tail(
          "--precompile",
          "precompile all methods instead of installing stubs") do |p|
        @options.precompile = p
      end

      opts.on_tail(
          "-O level",
          "set the optimization level") do |o|
        @options.optimization_level = o
      end

      opts.on_tail(
          "--ruby-prof",
          "use the ruby-prof profiler") do |p|
        @ruby_prof = p
      end

      opts.on_tail(
          "--prof-fmt=p",
          "format profiler output with printer p") do |p|
        @ruby_prof_printer = p
      end

      opts.on_tail(
          "--prof-out=file",
          "write profiler output to file") do |file|
        @ruby_prof_file = file
      end

      opts.on_tail(
          "--copyright",
          "print the copyright and exit") do
        puts COPYRIGHT
        exit()
      end

      opts.on_tail(
          "--version",
          "print the version and exit") do
        puts VERSION
        exit()
      end

      opts.on_tail(
          "-h",
          "--help",
          "show this help message and exit") do
        puts opts.banner
        opts.instance_eval do
          visit(:each_option) do |o|
            left = (o.short + o.long).join(', ')
            left << o.arg if o.arg
            left = left.ljust(opts.summary_width)
            right = o.desc
            # p o
            puts "  #{left} #{right}"
          end
        end
        exit()
      end

      opts.order!(args) do |arg|
        args.unshift arg
        opts.terminate
      end
    end
  end

  def enable_jit_log(lvl)
    Ludicrous.logger = Logger.new(STDERR)
    Ludicrous.logger.formatter = proc { |level, time, progname, msg|
      "#{level}: #{msg}\n"
    }
    if(lvl)
      Ludicrous.logger.level = Logger.const_get(lvl.upcase)
    end
  end

  def jit_compile_all_modules
    # TODO: Not sure why this one has to come first...
    jit_compile_module(Module)

    # We'll have to compile these anyway
    jit_compile_module(Ludicrous::JITCompiled)
    jit_compile_module(Kernel)
    jit_compile_module(JIT::Value)
    jit_compile_module(JIT::Function)
    jit_compile_module(Node)
    jit_compile_module(MethodSig)
    jit_compile_module(Method)
    jit_compile_module(UnboundMethod)

    ObjectSpace.each_object(Module) do |m|
      jit_compile_module(m) if m != Object
    end

    # Compile this one last
    jit_compile_module(Object)
  end

  def jit_compile_module(m)
    m.go_plaid(@options)
  end

  def run
    if @ruby_prof then
      begin
        require 'rubygems'
      rescue LoadError
      end
      require 'ruby-prof'

      result = RubyProf.profile { run_ }

      if @ruby_prof_printer =~ /Printer$/ then
        printer_name = @ruby_prof_printer
      else
        printer_name = @ruby_prof_printer + "Printer"
      end

      printer = RubyProf.const_get(printer_name).new(result)

      if @ruby_prof_file then
        File.open(@ruby_prof_file, 'w') do |out|
          printer.print(out, 0)
        end
      else
        printer.print(STDOUT, 0)
      end
    else
      # TODO: fix the backtrace if an exception is raised
      run_
      exit()
    end
  end

  def run_
    jit_compile_all_modules

    if @cd then
      Dir.chdir @cd
    end

    @require.each do |feature|
      require feature
    end

    if @dash_e.size > 0 then
      program = @dash_e.join("\n")
      return run_toplevel(program, '-e')
    elsif ARGV[0].nil? or ARGV[0] == '-'
      ARGV.shift
      program = STDIN.read
      $0.replace('-')
      return run_toplevel(program, '-')
    else
      filename = ARGV.shift
      program = File.read(filename)
      $0.replace(filename)
      return run_toplevel(program, filename)
    end
  end
  private :run_

  def run_toplevel(program, filename)
    if f = compile_toplevel(program, filename) then
      return run_toplevel_compiled(f)
    else
      return run_toplevel_interpreted(program, filename)
    end
  end

  def run_toplevel_compiled(f)
    LUDICROUS_CALL_TOPLEVEL.call(f)
  end

  def run_toplevel_interpreted(program, filename)
    eval(program, @binding, filename)
  end

  def compile_toplevel(program, filename)
    f = nil
    begin
      Ludicrous.logger.info "Compiling toplevel..."
      node = Node.compile_string(program, filename)
      f = node.ludicrous_compile_toplevel(@toplevel_self)
      Ludicrous.logger.info "Toplevel succeeded"
      return f
    rescue
      Ludicrous.logger.error "Toplevel failed: #{$!} (#{$!.backtrace[0]})"
      return nil
    end

  end
end

if __FILE__ == $0 then
  binding = binding()
  toplevel_self = self
  runner = LudicrousRunner.new(ARGV, binding, toplevel_self)
  runner.run
end

